# Linux Basic Day 2

2020.07.22.

* vi 편집기

  * 사용 방법을 익히는게 관건
  * command mode : 복사, 삭제, 이동
  * edit mode : 편집
  * last line mode : 저장, 종료, 
  * visual mode : 블럭을 잡을 수 있음. 

* 단축키 iaoIAO

  * 소문자 - 커서가 앞이거나, 위
  * 대문자 - 커서가 뒤이거나 아래

  `R` replace 모드 - 한 라인에 대해서만 덮어씀. 

  `r` 문자 하나를 수정할 때 덮어쓰기 이용

  `^`라인의 맨 앞으로 커서 이동

  `:set nu` `:35` 35번 줄로 이동

  `dw`단어 지우기 , 단어 : 커서~ 구분자, 띄어쓰기는 양쪽간에 다 구분자가 됨. 

  양쪽 = 특수문자, 

  `d^`, `d$`

  `dd` 

  `yy` 한라인 복사, 내용복사, 라인복사 구분하기. 

  `u` vi 편집기 프로세스가 돌아가는 동안 했던 작업을 되돌릴 수 있음. 저장 여부와 관계 없음. 

  `:w passwd1`상대경로에 다음과 같은 파일이름으로 저장. 저장했다고 바로 새로 저장한 파일이 열린 것은 아님. 

* `:1,5 s/2/5/



---

### 쉘 메타문자

* 경로 이름 메타 문자

`~` 현재 로그인된 사용자의 홈 디렉토리

`~+` 현재 작업 디렉토리

`~-` 이전 작업 디렉토리

​	`ls ~+` 현재 작업 디렉토리의 내용 확인

`-` 이전 작업 디렉토리

​	`cd -` 이전 디렉토리로 이동



* 파일 이름 대체 문자

  `*` 파일 이름의 일부를 대체. 숨겨진 파일에는 적용되지 않음. 

  `?` 하나의 문자를 대체하는 문자 ex. `ls f???A`

  `[]` 하나의 문자를 대체하는 문자의 범위 지정

  

* 인용부호 메타문자

  * `echo` 아규먼트로 오는 문자열을 화면으로 출력해주는 명령어

    ```{linux}
    # echo User
    User
    # echo $USER
    root #변수로서의 $
    ```

  `''` 홑따옴표 내의 모든 메타 문자를 일반문자로 취급

  `""` $, ``, \ 를 제외한 나머지 메타문자는 일반 문자 취급

  ​	단, 여기서도 \를 활용하면 메타문자는 일반문자로 취급.

  `` 특정 명령어의 결과를 출력
  
  `$()`특정 명령어의 결과를 출력   
  
  

* 방향 재지정 메타문자

방향재지정 메타문자는 에러값 보기 싫을 때 활용함. 

에러값 쓰레기통으로 넣고 정상값만 화면에 보기 위해서

`lt 2> /dev/null` 장치 내의 블랙홀로 보낸다고 생각하면 됨.  

`2>>/dev/null 1>>r01` 명령어를 연결해서 쓸 수 있음.



> 설정에서 > 하나만 쓰면 **덮어쓸 수 있음**. 그러면 설정 다 날아감. 
>
> 수정파일은 그냥 직접 들어가서 고치세요...! 큰일납니다. 



`2>&1` 파일 디스크립터 2번인 표준 에러를 파일 디스크립터 1번인 표준 출력과 같은 파일에 저장

&>과 헷갈리지 않기. 



`|grep`은 많이 씀 앞의 내용을 뒤 명령어의 아규먼트로 입력함. 

계속 결과값을 잇도록 연결할 수 있음. 그러나 >과 |을 같이 쓰면 저장만 되고 출력이 안됨. 

그래서 `|tee` 라고 하면 저장도 같이 함.  이때 순서가 중요함. `tee`가 뒤로 가는게 좋음. 



`ls -l ~-/` 이전 디렉토리 정보 확인



tip) `*n1*`이라고 씀으로써 기준점을 만드는 부분.  그냥 `*1*` 이라고 썼을 때 의도치 않은 파일이 들어올 수 있음. 



파일을 모두 만든 뒤, 이름으로 묶어서 해당 폴더에 넣으면 된다. 

tip 2) 확장자를 활용하는게 더 빠르다..!



---

### 프로세스 제어

* 프로세스의 개념과 종류

  프로세스 컴퓨터에서 실행되는 모든 프로그램

  부모, 자식, 좀비, 고아, 데모 프로세스



`ps -f` 현재 구동 중인 프로세스의 목록을 상세하게 출력

`ps -e` 시스템상의 모든 프로세스 정보 출력



`pgrep -l sleep` sleep이라는 패턴에 해당하는 정보 출력

`kill (PID NUM)` 프로세스 종료, 옵션 -1초기화, -2 interrupt, -9 프로세스 강제 종료, -15 디폴트	



#### 작업관리

Foreground 작업 : 터미널에서 명령어를 실행할 때 명령어 실행이 종료될 때까지 터미널 화면을 사용하여 동장

Background작업 : 명령어 끝에 `&`기호를 붙이면 터미널 화면을 사용하지 않고 실행

`jobs` 동작, 정지 중인 모든 작업 출력

`bg %작업ID` 지정한 작업을 백그라운드에서 동작시킴

`fg %작업ID` 지정한 작업을 백그라운드에서 포그라운드로 가져옴



#### 아카이브와 압축

아카이브 - 압축률이 제로. 

* tar 덮어쓸 때 해제와 압축 모두 피드백이 없음.  대화형이 없으므로 함부로 해제하면 안됨. 

  * 옵션

    `cvf` 압축 파일 만들기

    `xvf ` 압축 파일 해제

    `tvf` 압축 파일 리스트 확인

    `v` 상세

  * 만들 때 .tar 확장자를 붙여야 함. 그렇지 않으면 타르 파일인지 확인하기 어려움. 

  * 경로를 쓰면 모두 창고로 넣음. 풀릴 때 절대경로가 풀리면..경로까지 포함함. 루트/를 빼야함.

  * touch로 만든 파일의 경우 파일 이름과 아이노드 데이터가 있어 용량이 생김. 데이터 블록의 크기가 0일뿐이다. 

*  압축

  * gz  

    옵션에 따라 속도가 달라짐. 

    풀 때는 옵션 덜 붙여도 가능은 함. 

    tar 외의 **명령어** 는 기존 파일 자체를 압축으로 변환시킴. 안전성을 위해 tar에 옵션사용

     `tar zcvf z.tar.gz dir01/a{0001..1000}`

    gzip tar파일을 아카이브를 만들어쓰는 용도 이건 내용이 있다 정도만 알고 있으면 됨. 

    지정 아카이브 및 압축해제 : -C 지정경로, 설정하지 않으면 해당 위치에 풀림.

    아카이브를 위해서는 디렉토리 읽기 권한이 필요함. 

    아카이브 만들기 위해서는 쓰기 권한도 필요함. = 복잡함. 



----

## 사용자 및 그룹 관리

### 계정 관리 파일

`who am i` 내가 처음 로그인한 기준으로 사용자 정보를 보여줌

`whoami ` 현재 내가 로그인한 사용자를 보여줌

su pw 알아야 함. 

`su` , `su -` 차이 사용자만 전환 / 환경까지 획득

`sudo` 는 파일 내에 보고되어 있는 그룹만 가능 ex. wheel 

`sudo -il` -i옵션 -> 루트 사용자 자체로 전환



### 사용자 계정 

`useradd [option] [username]`

`' '` = null

스켈레톤 - 뼈대SKEL 